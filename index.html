<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LCD单色液晶显示位图编辑器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        .header {
            display: flex;
            padding: 10px 20px;
            background-color: #333;
            color: white;
            align-items: center;
            justify-content: space-between;
            height: 60px;
        }
        .header h1 {
            margin: 0;
            font-size: 1.2rem;
        }
        .header-links {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 0.9rem;
        }
        .header-links a {
            color: #4CAF50;
            text-decoration: none;
            transition: color 0.3s;
        }
        .header-links a:hover {
            color: #66BB6A;
            text-decoration: underline;
        }
        .header-links span {
            color: #ccc;
        }
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .left-panel {
            width: 25%;
            min-width: 250px;
            max-width: 350px;
            background-color: #fff;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            padding: 10px;
            overflow-y: auto;
        }
        .editor-container {
            flex: 1;
            position: relative;
            overflow: auto;
            padding: 15px;
        }
        .canvas-container {
            position: absolute;
            top: 15px;
            left: 15px;
        }
        canvas {
            border: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .top-panel {
            background-color: #fff;
            border-bottom: 1px solid #ddd;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .input-group {
            display: flex;
            align-items: center;
            margin-right: 15px;
            white-space: nowrap;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="number"] {
            width: 60px;
            padding: 5px;
            margin-left: 5px;
        }
        input[type="text"] {
            padding: 5px;
            margin-left: 5px;
        }
        .control-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .control-section h3 {
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #333;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        .slider-value {
            width: 30px;
            text-align: center;
        }
        .checkbox-container {
            margin: 10px 0;
        }
        select {
            margin: 5px;
            padding: 5px;
        }
        /* Tab样式 */
        .tab-container {
            width: 100%;
        }
        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 10px;
        }
        .tab-button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-bottom: none;
            background-color: #f8f8f8;
            cursor: pointer;
            margin-right: 2px;
            border-radius: 4px 4px 0 0;
            color: #000;
            transition: all 0.2s ease;
            font-weight: normal;
        }
        .tab-button.active {
            background-color: #fff;
            border-bottom: 1px solid #fff;
            margin-bottom: -1px;
            font-weight: bold;
            color: #000;
        }
        .tab-button:hover:not(.active) {
            background-color: #f0f0f0;
            color: #000;
        }
        .tab-content {
            display: none;
            padding: 10px;
            border: 1px solid #ddd;
            border-top: none;
            background-color: #fff;
        }
        .tab-content.active {
            display: block;
        }
    </style>
    <!-- 引入字体库和字体文件 -->
    <script src="fonts.js"></script>
    <script src="fonts/font_8x8.js"></script>
    <script src="fonts/font_8x12.js"></script>
    <script src="fonts/font_8x16.js"></script>
    <script src="fonts/font_8x16_slim.js"></script>
    <script src="fonts/font_10x18.js"></script>
    <script src="fonts/font_12x22.js"></script>
    <script src="fonts/font_16x32.js"></script>
    <script src="fonts/font_24x48.js"></script>
    <script src="fonts/font_number_32x48.js"></script>
    <script src="fonts/font_segment_32x48.js"></script>
    <script src="fonts/font_segment_24x32.js"></script>
    <!-- 引入汉字字库支持 -->
    <script src="gb2312_encoder.js"></script>
    <script src="hzk_fonts.js"></script>
    <!-- 引入二维码生成库（多个备选源） -->
    <script src="libs/qrcode.min.js"></script>
    <script>
        // 检查QRCode库是否加载成功
        window.addEventListener('load', function() {
            if (typeof QRCode === 'undefined') {
                alert('二维码库加载失败，请检查网络连接或刷新页面重试。');
            } else {
                console.log('QRCode库加载成功');
            }
        });
    </script>
</head>
<body>
    <div class="header">
        <h1>LCD单色液晶显示位图编辑器</h1>
        <div class="header-links">
            <a href="https://www.eehut.com/post/lcd_bitmap_editor/" target="_blank">使用帮助</a>
            <a href="https://github.com/eehut/lcd_bitmap_editor" target="_blank">GitHub</a>
            <span>问题反馈：<a href="mailto:179712066@qq.com">179712066@qq.com</a></span>
        </div>
    </div>
    
    <div class="top-panel">
        <div class="input-group">
            <label>ASCII字库:</label>
            <select id="fontSelect" class="font-select">
                <option value="font_8x8">8x8 字体</option>
                <option value="font_8x12">8x12 字体</option>
                <option value="font_8x16">8x16 字体</option>
                <option value="font_8x16_slim">8x16-slim 字体</option>
                <option value="font_10x18">10x18 字体</option>
                <option value="font_12x22">12x22 字体</option>
                <option value="font_16x32">16x32 字体</option>
                <option value="font_24x48">24x48 字体</option>
                <option value="font_number_32x48">数字 32x48 字体</option>
                <option value="font_segment_24x32">7段数码管 24x32 字体</option>
                <option value="font_segment_32x48">7段数码管 32x48 字体</option>
                <option value="use_hzk">使用汉字库</option>
            </select>
        </div>

        <div class="input-group">
            <label>汉字库:</label>
            <select id="hzkSelect" class="hzk-select">
                <option value="">不使用</option>
                <option value="HZK12">HZK12 (12x12)</option>
                <option value="HZK16" selected>HZK16 (16x16)</option>
                <option value="HZK24">HZK24 (24x24)</option>
                <option value="HZK32">HZK32 (32x32)</option>
                <option value="HZK40">HZK40 (40x40)</option>
                <option value="HZK48">HZK48 (48x48)</option>
            </select>
        </div>

        <div class="input-group">
            <label>X:</label>
            <input type="number" id="textX" value="0" min="0" max="255" style="width: 50px;">
            <label>Y:</label>
            <input type="number" id="textY" value="0" min="0" max="255" style="width: 50px;">
        </div>
        <div class="input-group">
            <label>文本:</label>
            <input type="text" id="asciiText" placeholder="输入文本(支持汉字)" style="width: 200px;">
            <label style="margin-left: 10px;">
                <input type="checkbox" id="invertText"> 反显
            </label>
            <button onclick="drawText()">放置文本</button>
        </div>
        <div class="input-group">
            <button onclick="exportBitmap()">导出字模</button>
        </div>


    </div>
    
    <div class="main-content">
        <div class="left-panel">
            <div class="control-section">
                <h3>屏幕尺寸</h3>
                <div class="input-group">
                    <label>宽度:</label>
                    <input type="number" id="width" value="128" min="1" max="256">
                </div>
                <div class="input-group">
                    <label>高度:</label>
                    <input type="number" id="height" value="64" min="1" max="256">
                </div>
                <button onclick="updateCanvas()">更新尺寸</button>
            </div>
            
            <div class="control-section">
                <h3>编辑工具</h3>
                <button onclick="clearCanvas()">清屏</button>
                <button onclick="undo()" id="undoBtn" disabled>撤销</button>
            </div>
            
            <div class="control-section">
                <h3>显示设置</h3>
                <div class="slider-container">
                    <label>缩放:</label>
                    <input type="range" id="scale" min="1" max="20" value="8" oninput="updateScaleValue(this.value)">
                    <span class="slider-value" id="scaleValue">8</span>
                </div>
                <div class="checkbox-container">
                    <label>
                        <input type="checkbox" id="showGrid" checked onchange="drawBitmap()">
                        显示网格
                    </label>
                </div>
            </div>
            
            <div class="control-section">
                <h3>图形工具</h3>
                <div class="tab-container">
                    <div class="tab-buttons">
                        <button class="tab-button active" onclick="switchTab('qr')">二维码</button>
                        <button class="tab-button" onclick="switchTab('image')">图片</button>
                    </div>
                    
                    <!-- 二维码标签页 -->
                    <div id="qr-tab" class="tab-content active">
                        <div class="input-group">
                            <label>内容:</label>
                            <textarea id="qrText" placeholder="输入要生成二维码的文本" style="width: 100%; height: 60px; resize: vertical; margin: 5px 0;"></textarea>
                        </div>
                        <div class="input-group">
                            <label>纠错级别:</label>
                            <select id="qrErrorLevel" style="width: 100%;">
                                <option value="L">L (约7%)</option>
                                <option value="M" selected>M (约15%)</option>
                                <option value="Q">Q (约25%)</option>
                                <option value="H">H (约30%)</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>版本 (可选):</label>
                            <select id="qrVersion" style="width: 100%;">
                                <option value="auto" selected>自动选择</option>
                                <option value="1">1 (21x21)</option>
                                <option value="2">2 (25x25)</option>
                                <option value="3">3 (29x29)</option>
                                <option value="4">4 (33x33)</option>
                                <option value="5">5 (37x37)</option>
                                <option value="6">6 (41x41)</option>
                                <option value="7">7 (45x45)</option>
                                <option value="8">8 (49x49)</option>
                                <option value="9">9 (53x53)</option>
                                <option value="10">10 (57x57)</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>X位置:</label>
                            <input type="number" id="qrX" value="0" min="0" max="255" style="width: 100%; margin: 2px 0;">
                        </div>
                        <div class="input-group">
                            <label>Y位置:</label>
                            <input type="number" id="qrY" value="0" min="0" max="255" style="width: 100%; margin: 2px 0;">
                        </div>
                        <div class="checkbox-container">
                            <label>
                                <input type="checkbox" id="qrInvert"> 反转颜色
                            </label>
                        </div>
                        <div class="input-group">
                            <label>像素模式:</label>
                            <select id="qrPixelMode" style="width: 100%; margin: 2px 0;">
                                <option value="1">1x1 像素</option>
                                <option value="2">2x2 像素</option>
                            </select>
                        </div>
                        <button onclick="generateQRCode()" style="width: 100%; margin: 5px 0;">生成二维码</button>
                        <div style="margin: 10px 0; border-top: 1px solid #eee; padding-top: 10px;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">常用模板:</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                                <button onclick="insertQRTemplate('url')" style="font-size: 11px; padding: 3px;">网址</button>
                                <button onclick="insertQRTemplate('wifi')" style="font-size: 11px; padding: 3px;">WiFi</button>
                                <button onclick="insertQRTemplate('email')" style="font-size: 11px; padding: 3px;">邮件</button>
                                <button onclick="insertQRTemplate('phone')" style="font-size: 11px; padding: 3px;">电话</button>
                                <button onclick="insertQRTemplate('sms')" style="font-size: 11px; padding: 3px;">短信</button>
                                <button onclick="insertQRTemplate('vcard')" style="font-size: 11px; padding: 3px;">名片</button>
                            </div>
                        </div>
                        <div id="qrPreview" style="margin-top: 10px; text-align: center; border: 1px solid #ddd; background: #f9f9f9; min-height: 40px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #666;">
                            二维码预览
                        </div>
                    </div>
                    
                    <!-- 图片标签页 -->
                    <div id="image-tab" class="tab-content">
                        <div class="input-group">
                            <label>选择图片:</label>
                            <input type="file" id="imageUpload" accept=".png,.bmp" style="width: 100%; margin: 5px 0;">
                        </div>
                        <div class="input-group">
                            <label>缩放模式:</label>
                            <select id="scaleMode" style="width: 100%; margin: 2px 0;">
                                <option value="fit">适应屏幕</option>
                                <option value="fill">填充屏幕</option>
                                <option value="original">原始尺寸</option>
                                <option value="custom">自定义比例</option>
                            </select>
                        </div>
                        <div id="customScaleGroup" class="input-group" style="display: none;">
                            <label>缩放比例:</label>
                            <input type="number" id="customScale" value="0.5" min="0.1" max="10" step="0.1" style="width: 100%; margin: 2px 0;">
                        </div>
                        <div class="input-group">
                            <label>颜色阈值 (0-255):</label>
                            <div class="slider-container">
                                <input type="range" id="colorThreshold" min="0" max="255" value="128" oninput="updateThresholdValue(this.value)">
                                <span class="slider-value" id="thresholdValue">128</span>
                            </div>
                            <div style="font-size: 12px; color: #666;">低于此值的像素将显示为黑色</div>
                        </div>
                        <div class="input-group">
                            <label>X位置:</label>
                            <input type="number" id="imageX" value="0" min="0" max="255" style="width: 100%; margin: 2px 0;">
                        </div>
                        <div class="input-group">
                            <label>Y位置:</label>
                            <input type="number" id="imageY" value="0" min="0" max="255" style="width: 100%; margin: 2px 0;">
                        </div>
                        <div class="checkbox-container">
                            <label>
                                <input type="checkbox" id="imageInvert"> 反转颜色
                            </label>
                        </div>
                        <button onclick="processAndDrawImage()" style="width: 100%; margin: 5px 0;">处理图片</button>
                        <div id="imagePreview" style="margin-top: 10px; text-align: center; border: 1px solid #ddd; background: #f9f9f9; min-height: 60px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #666;">
                            图片预览
                        </div>
                        <div id="imageInfo" style="margin-top: 5px; font-size: 12px; color: #666; text-align: center;">
                            尚未选择图片
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="editor-container">
            <div class="canvas-container">
                <canvas id="bitmapCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- 添加导出模态框 -->
    <div id="exportModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);">
        <div style="background-color: white; margin: 10% auto; padding: 20px; width: 80%; max-width: 700px; max-height: 80%; overflow: auto; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.3);">
            <h2>C语言字模数据</h2>
            <pre id="exportData" style="background-color: #f5f5f5; padding: 10px; white-space: pre-wrap; overflow-x: auto; font-family: monospace; border: 1px solid #ccc;"></pre>
            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <button onclick="document.getElementById('exportModal').style.display='none'">关闭</button>
                <button onclick="copyToClipboard()">复制到剪贴板</button>
            </div>
        </div>
    </div>



    <script>
        // 检查LCDFont是否正确导入
        console.log("LCDFont对象:", typeof LCDFont, LCDFont ? Object.keys(LCDFont) : "未定义");
        if (LCDFont && LCDFont.version) {
            console.log("LCDFont版本:", LCDFont.version);
        } else {
            console.warn("警告: LCDFont版本信息不可用，可能使用了旧版本！请清除浏览器缓存后刷新。");
        }
        
        // 检查字体对象是否正确导入
        console.log("font_8x8:", typeof font_8x8, font_8x8 ? "已加载" : "未加载");
        console.log("font_8x12:", typeof font_8x12, font_8x12 ? "已加载" : "未加载");
        console.log("font_8x16:", typeof font_8x16, font_8x16 ? "已加载" : "未加载");
        console.log("font_8x16_slim:", typeof font_8x16_slim, font_8x16_slim ? "已加载" : "未加载");
        console.log("font_10x18:", typeof font_10x18, font_10x18 ? "已加载" : "未加载");
        console.log("font_12x22:", typeof font_12x22, font_12x22 ? "已加载" : "未加载");
        console.log("font_16x32:", typeof font_16x32, font_16x32 ? "已加载" : "未加载");
        console.log("font_24x48:", typeof font_24x48, font_24x48 ? "已加载" : "未加载");
        console.log("font_number_32x48:", typeof font_number_32x48, font_number_32x48 ? "已加载" : "未加载");
        console.log("font_segment_24x32:", typeof font_segment_24x32, font_segment_24x32 ? "已加载" : "未加载");
        console.log("font_segment_32x48:", typeof font_segment_32x48, font_segment_32x48 ? "已加载" : "未加载");
        
        // 如果字体未加载，显示错误信息
        function checkFonts() {
            const fontSelect = document.getElementById('fontSelect');
            const selectedFont = fontSelect.value;
            const fontObj = window[selectedFont];
            
            if (!fontObj) {
                alert(`错误：${selectedFont} 字体未正确加载！`);
                return false;
            }
            return true;
        }
        
        let canvas = document.getElementById('bitmapCanvas');
        let ctx = canvas.getContext('2d');
        let bitmap = [];
        let scale = 8;
        const LCD_BACKGROUND = '#e0e0e0'; // 传统LCD面板的灰色
        const GRID_COLOR = '#d0d0d0'; // 浅灰色网格
        let isDrawing = false; // 添加绘制状态标志
        let lastX = -1; // 记录上一个绘制的X坐标
        let lastY = -1; // 记录上一个绘制的Y坐标
        let drawMode = 1; // 1表示绘制，0表示擦除
        const MARGIN_TOP = 25; // 上边距，用于显示刻度
        const MARGIN_LEFT = 25; // 左边距，用于显示刻度
        const MARGIN_BOTTOM = 25; // 下边距，用于显示刻度
        const MARGIN_RIGHT = 25; // 右边距，用于显示刻度
        const SCALE_COLOR = '#3366CC'; // 刻度线和刻度值的颜色，使用更鲜明的蓝色
        
        // 历史状态存储，用于撤销功能
        let history = [];
        const MAX_HISTORY = 5; // 最大历史记录数

        function initBitmap(width, height) {
            bitmap = Array(height).fill().map(() => Array(width).fill(0));
        }

        // 保存当前状态到历史记录
        function saveState() {
            // 深拷贝当前bitmap
            const stateCopy = bitmap.map(row => [...row]);
            
            // 添加到历史记录
            history.push(stateCopy);
            
            // 如果历史记录超过最大值，删除最旧的
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
            
            // 启用撤销按钮
            document.getElementById('undoBtn').disabled = false;
        }

        // 撤销功能
        function undo() {
            if (history.length > 0) {
                // 从历史记录中获取上一个状态
                bitmap = history.pop();
                
                // 如果没有更多历史记录，禁用撤销按钮
                if (history.length === 0) {
                    document.getElementById('undoBtn').disabled = true;
                }
                
                // 重绘
                drawBitmap();
            }
        }

        // 清屏功能
        function clearCanvas() {
            // 保存当前状态到历史记录
            saveState();
            
            // 清空位图
            const width = bitmap[0].length;
            const height = bitmap.length;
            initBitmap(width, height);
            
            // 重绘
            drawBitmap();
        }

        function updateCanvas() {
            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            
            // 保存原有的位图数据
            const oldBitmap = bitmap;
            
            // 画布大小增加边距，为刻度线预留空间
            canvas.width = width * scale + MARGIN_LEFT + MARGIN_RIGHT;
            canvas.height = height * scale + MARGIN_TOP + MARGIN_BOTTOM;
            
            // 初始化新的位图
            initBitmap(width, height);
            
            // 如果存在旧的位图数据，则复制到新的位图中
            if (oldBitmap.length > 0) {
                const minWidth = Math.min(width, oldBitmap[0].length);
                const minHeight = Math.min(height, oldBitmap.length);
                
                for (let y = 0; y < minHeight; y++) {
                    for (let x = 0; x < minWidth; x++) {
                        bitmap[y][x] = oldBitmap[y][x];
                    }
                }
            }
            
            // 清空历史记录
            history = [];
            document.getElementById('undoBtn').disabled = true;
            
            drawBitmap();
        }

        function updateScaleValue(value) {
            document.getElementById('scaleValue').textContent = value;
            scale = parseInt(value);
            
            // 保存当前屏幕的尺寸
            const width = bitmap[0].length;
            const height = bitmap.length;
            
            // 更新画布尺寸，保持左上角原点位置不变
            canvas.width = width * scale + MARGIN_LEFT + MARGIN_RIGHT;
            canvas.height = height * scale + MARGIN_TOP + MARGIN_BOTTOM;
            
            drawBitmap();
        }

        function drawGrid() {
            if (!document.getElementById('showGrid').checked) return;
            
            ctx.strokeStyle = GRID_COLOR;
            ctx.lineWidth = 0.5;

            // 绘制垂直线
            for (let x = 0; x <= bitmap[0].length; x++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN_LEFT + x * scale, MARGIN_TOP);
                ctx.lineTo(MARGIN_LEFT + x * scale, MARGIN_TOP + bitmap.length * scale);
                ctx.stroke();
                
                // 每8个点显示一个刻度
                if (x % 8 === 0) {
                    // 绘制上边界刻度线
                    ctx.beginPath();
                    ctx.strokeStyle = SCALE_COLOR;
                    ctx.lineWidth = 1.0;
                    ctx.moveTo(MARGIN_LEFT + x * scale, MARGIN_TOP - 5);
                    ctx.lineTo(MARGIN_LEFT + x * scale, MARGIN_TOP);
                    ctx.stroke();
                    
                    // 绘制上边界刻度值
                    ctx.fillStyle = SCALE_COLOR;
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(x.toString(), MARGIN_LEFT + x * scale, MARGIN_TOP - 8);
                    
                    // 绘制下边界刻度线
                    ctx.beginPath();
                    ctx.moveTo(MARGIN_LEFT + x * scale, MARGIN_TOP + bitmap.length * scale);
                    ctx.lineTo(MARGIN_LEFT + x * scale, MARGIN_TOP + bitmap.length * scale + 5);
                    ctx.stroke();
                    
                    // 绘制下边界刻度值
                    ctx.textAlign = 'center';
                    ctx.fillText(x.toString(), MARGIN_LEFT + x * scale, MARGIN_TOP + bitmap.length * scale + 15);

                    // 恢复网格线样式
                    ctx.strokeStyle = GRID_COLOR;
                    ctx.lineWidth = 0.5;
                }
            }

            // 绘制水平线
            for (let y = 0; y <= bitmap.length; y++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN_LEFT, MARGIN_TOP + y * scale);
                ctx.lineTo(MARGIN_LEFT + bitmap[0].length * scale, MARGIN_TOP + y * scale);
                ctx.stroke();
                
                // 每8个点显示一个刻度
                if (y % 8 === 0) {
                    // 绘制左边界刻度线
                    ctx.beginPath();
                    ctx.strokeStyle = SCALE_COLOR;
                    ctx.lineWidth = 1.0;
                    ctx.moveTo(MARGIN_LEFT - 5, MARGIN_TOP + y * scale);
                    ctx.lineTo(MARGIN_LEFT, MARGIN_TOP + y * scale);
                    ctx.stroke();
                    
                    // 绘制左边界刻度值
                    ctx.fillStyle = SCALE_COLOR;
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(y.toString(), MARGIN_LEFT - 8, MARGIN_TOP + y * scale + 3);
                    
                    // 绘制右边界刻度线
                    ctx.beginPath();
                    ctx.moveTo(MARGIN_LEFT + bitmap[0].length * scale, MARGIN_TOP + y * scale);
                    ctx.lineTo(MARGIN_LEFT + bitmap[0].length * scale + 5, MARGIN_TOP + y * scale);
                    ctx.stroke();
                    
                    // 绘制右边界刻度值
                    ctx.textAlign = 'left';
                    ctx.fillText(y.toString(), MARGIN_LEFT + bitmap[0].length * scale + 8, MARGIN_TOP + y * scale + 3);

                    // 恢复网格线样式
                    ctx.strokeStyle = GRID_COLOR;
                    ctx.lineWidth = 0.5;
                }
            }
        }

        function drawBitmap() {
            // 清除整个画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制LCD背景色
            ctx.fillStyle = LCD_BACKGROUND;
            ctx.fillRect(MARGIN_LEFT, MARGIN_TOP, bitmap[0].length * scale, bitmap.length * scale);
            
            // 绘制位图
            ctx.fillStyle = 'black';
            for (let y = 0; y < bitmap.length; y++) {
                for (let x = 0; x < bitmap[y].length; x++) {
                    if (bitmap[y][x]) {
                        ctx.fillRect(MARGIN_LEFT + x * scale, MARGIN_TOP + y * scale, scale, scale);
                    }
                }
            }

            // 绘制网格
            drawGrid();
        }

        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: Math.floor((e.clientX - rect.left - MARGIN_LEFT) / scale),
                y: Math.floor((e.clientY - rect.top - MARGIN_TOP) / scale)
            };
        }

        function togglePixel(x, y) {
            if (x >= 0 && x < bitmap[0].length && y >= 0 && y < bitmap.length) {
                bitmap[y][x] = drawMode;
                drawBitmap();
            }
        }

        function drawLine(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                togglePixel(x0, y0);
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }

        canvas.addEventListener('mousedown', function(e) {
            if (e.button === 0) { // 左键按下
                isDrawing = true;
                
                // 在开始绘制前保存当前状态
                saveState();
                
                const coords = getCanvasCoordinates(e);
                lastX = coords.x;
                lastY = coords.y;
                // 根据当前像素状态决定绘制模式
                if (lastX >= 0 && lastX < bitmap[0].length && lastY >= 0 && lastY < bitmap.length) {
                    drawMode = bitmap[lastY][lastX] ? 0 : 1;
                    togglePixel(lastX, lastY);
                }
            }
        });

        canvas.addEventListener('mousemove', function(e) {
            if (isDrawing) {
                const coords = getCanvasCoordinates(e);
                if (coords.x !== lastX || coords.y !== lastY) {
                    if (lastX >= 0 && lastX < bitmap[0].length && lastY >= 0 && lastY < bitmap.length &&
                        coords.x >= 0 && coords.x < bitmap[0].length && coords.y >= 0 && coords.y < bitmap.length) {
                        drawLine(lastX, lastY, coords.x, coords.y);
                        lastX = coords.x;
                        lastY = coords.y;
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', function(e) {
            if (e.button === 0) { // 左键释放
                isDrawing = false;
                lastX = -1;
                lastY = -1;
            }
        });

        canvas.addEventListener('mouseleave', function() {
            isDrawing = false;
            lastX = -1;
            lastY = -1;
        });



        // 改进的 drawText 函数，支持汉字和ASCII混合
        async function drawText() {
            // 保存当前状态到历史记录
            saveState();
            
            const text = document.getElementById('asciiText').value;
            const x = parseInt(document.getElementById('textX').value);
            const y = parseInt(document.getElementById('textY').value);
            const isInvert = document.getElementById('invertText').checked;
            const asciiFont = document.getElementById('fontSelect').value;
            const hzkFontName = document.getElementById('hzkSelect').value;
            
            console.log(`绘制文本: "${text}", 位置: (${x},${y}), 反显: ${isInvert}, ASCII字体: ${asciiFont}, 汉字库: ${hzkFontName || '无'}`);
            
            // 检查是否使用汉字库
            const useHzkForAscii = (asciiFont === 'use_hzk');
            
            // 获取ASCII字体对象（如果不使用汉字库）
            let asciiFontObj = null;
            if (!useHzkForAscii) {
                asciiFontObj = window[asciiFont];
                if (!asciiFontObj) {
                    alert(`错误：字体 ${asciiFont} 未加载！`);
                    return;
                }
            }
            
            // 获取汉字库对象
            let hzkFont = null;
            if (hzkFontName) {
                hzkFont = hzkFontManager.getFont(hzkFontName);
                if (hzkFont) {
                    // 加载汉字库（如果尚未加载）
                    if (!hzkFont.isLoaded) {
                        console.log(`正在加载汉字库 ${hzkFontName}...`);
                        const loaded = await hzkFont.load();
                        if (!loaded) {
                            alert(`错误：汉字库 ${hzkFontName} 加载失败！`);
                            hzkFont = null;
                        }
                    }
                } else {
                    console.warn(`汉字库 ${hzkFontName} 未找到`);
                }
            }
            
            // 确保GB2312编码器已初始化
            if (!gb2312Encoder.isLoaded) {
                await gb2312Encoder.loadMapping();
            }
            
            let currentX = x;
            let currentY = y;
            let skippedChars = 0;
            
            // 遍历文本中的每个字符
            for (let i = 0; i < text.length; i++) {
                const char = text.charAt(i);
                const charCode = char.charCodeAt(0);
                const isAscii = charCode < 128;
                
                let charDrawn = false;
                
                // 决定如何绘制字符
                if (isAscii) {
                    // ASCII字符
                    if (useHzkForAscii && hzkFont) {
                        // 使用汉字库绘制ASCII（汉字库中包含全角ASCII字符）
                        charDrawn = hzkFont.drawChar(bitmap, char, currentX, currentY, isInvert);
                        if (charDrawn) {
                            currentX += hzkFont.width;
                        }
                    } else if (asciiFontObj) {
                        // 使用ASCII字库绘制
                        charDrawn = drawAsciiChar(asciiFontObj, char, currentX, currentY, isInvert);
                        if (charDrawn) {
                            currentX += asciiFontObj.width;
                        }
                    }
                } else {
                    // 汉字
                    if (hzkFont) {
                        charDrawn = hzkFont.drawChar(bitmap, char, currentX, currentY, isInvert);
                        if (charDrawn) {
                            currentX += hzkFont.width;
                        } else {
                            console.warn(`无法绘制汉字 "${char}" (U+${charCode.toString(16).toUpperCase()})`);
                        }
                    } else {
                        console.warn(`汉字 "${char}" 需要汉字库支持，请选择汉字库`);
                    }
                }
                
                if (!charDrawn) {
                    skippedChars++;
                    // 如果无法绘制，跳过一个字符宽度
                    if (hzkFont) {
                        currentX += hzkFont.width;
                    } else if (asciiFontObj) {
                        currentX += asciiFontObj.width;
                    } else {
                        currentX += 8; // 默认宽度
                    }
                }
            }
            
            if (skippedChars > 0) {
                console.log(`共跳过 ${skippedChars} 个字符`);
            }
            
            drawBitmap();
        }
        
        // 绘制ASCII字符的辅助函数
        function drawAsciiChar(fontObj, char, x, y, isInvert) {
            const charCode = char.charCodeAt(0);
            
            // 检查字符是否被字体支持
            let isSupported = false;
            if (typeof LCDFont !== 'undefined' && typeof LCDFont.isCharSupported === 'function') {
                isSupported = LCDFont.isCharSupported(fontObj, char);
            } else {
                // 降级处理：手动检查字符是否支持
                if (fontObj.isNumberFont) {
                    isSupported = charCode >= 48 && charCode <= 57;
                } else {
                    isSupported = charCode >= 0 && charCode <= 127;
                }
            }
            
            if (!isSupported) {
                console.warn(`字符 "${char}" 不受字体 ${fontObj.width}x${fontObj.height} 支持`);
                return false;
            }
            
            try {
                // 获取字符在字体数据中的索引
                let index;
                if (typeof LCDFont !== 'undefined' && typeof LCDFont.getCharIndex === 'function') {
                    index = LCDFont.getCharIndex(fontObj, char);
                    // 验证索引是否正确（如果返回的是普通字体的索引，则重新计算）
                    if (fontObj.isNumberFont && index >= 0) {
                        const expectedIndex = (charCode - 48) * fontObj.bytesPerChar;
                        if (index !== expectedIndex && charCode >= 48 && charCode <= 57) {
                            index = expectedIndex;
                        }
                    }
                } else {
                    // 降级处理：直接计算索引
                    if (fontObj.isNumberFont) {
                        index = (charCode >= 48 && charCode <= 57) ? (charCode - 48) * fontObj.bytesPerChar : -1;
                    } else {
                        index = charCode * fontObj.bytesPerChar;
                    }
                }
                
                if (index < 0 || index >= fontObj.data.length) {
                    console.warn(`字符 "${char}" 索引 ${index} 超出范围`);
                    return false;
                }
                
                // 从字体数据中提取字符数据
                const charData = fontObj.data.slice(index, index + fontObj.bytesPerChar);
                
                // 计算每行需要的字节数
                const bytesPerRow = Math.ceil(fontObj.width / 8);
                
                // 绘制字符
                const canvasWidth = bitmap[0].length;
                const canvasHeight = bitmap.length;
                
                for (let row = 0; row < fontObj.height; row++) {
                    const rowStartIndex = row * bytesPerRow;
                    
                    for (let col = 0; col < fontObj.width; col++) {
                        const byteIndex = rowStartIndex + Math.floor(col / 8);
                        const bitPosition = 7 - (col % 8);
                        
                        const byte = charData[byteIndex] || 0;
                        const bit = (byte >> bitPosition) & 0x01;
                        
                        const targetX = x + col;
                        const targetY = y + row;
                        if (targetX >= 0 && targetX < canvasWidth && targetY >= 0 && targetY < canvasHeight) {
                            bitmap[targetY][targetX] = isInvert ? !bit : bit;
                        }
                    }
                }
                
                return true;
            } catch (error) {
                console.error(`绘制字符 "${char}" 时出错:`, error);
                return false;
            }
        }

        // 导出位图为C语言字模函数
        function exportBitmap() {
            const width = bitmap[0].length;
            const height = bitmap.length;
            
            // 计算每行需要的字节数，向上取整
            const bytesPerRow = Math.ceil(width / 8);
            const totalBytes = bytesPerRow * height;
            
            // 创建结果数组
            const bytes = new Array(totalBytes).fill(0);
            
            // 每行按MSB优先编码
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (bitmap[y][x]) {
                        // 计算在bytes数组中的索引
                        const byteIndex = y * bytesPerRow + Math.floor(x / 8);
                        // 在当前字节中的位位置（MSB优先，0是最高位，7是最低位）
                        const bitPosition = 7 - (x % 8);
                        // 设置对应的位
                        bytes[byteIndex] |= (1 << bitPosition);
                    }
                }
            }
            
            // 将字节数组转换为十六进制的C语言数组格式
            let codeOutput = `// ${width}x${height} 位图字模数据\n`;
            codeOutput += `// 总字节数: ${totalBytes}，每行字节数: ${bytesPerRow}\n`;
            codeOutput += `const unsigned char bitmap_${width}x${height}[] = {\n    `;
            
            for (let i = 0; i < bytes.length; i++) {
                codeOutput += `0x${bytes[i].toString(16).padStart(2, '0')}`;
                
                if (i < bytes.length - 1) {
                    codeOutput += ', ';
                    // 每8个字节换一行，使输出更整洁
                    if ((i + 1) % 8 === 0) {
                        codeOutput += '\n    ';
                    }
                }
            }
            
            codeOutput += '\n};';
            
            // 显示导出结果
            document.getElementById('exportData').textContent = codeOutput;
            document.getElementById('exportModal').style.display = 'block';
        }
        
        // 复制到剪贴板
        function copyToClipboard() {
            const exportText = document.getElementById('exportData').textContent;
            navigator.clipboard.writeText(exportText)
                .then(() => {
                    alert('已复制到剪贴板');
                })
                .catch(err => {
                    console.error('复制失败:', err);
                    alert('复制失败，请手动复制');
                });
        }
        
        // 初始化画布
        updateCanvas();
        
        // 测试LCDFont是否工作正常
        function testLCDFont() {
            try {
                // 在控制台显示方法
                console.log("LCDFont方法:", LCDFont.renderChar, LCDFont.renderText);
                
                // 创建一个测试canvas
                const testCanvas = document.createElement('canvas');
                testCanvas.width = 200;
                testCanvas.height = 50;
                testCanvas.style.border = '1px solid black';
                testCanvas.style.margin = '10px';
                document.body.appendChild(testCanvas);
                
                const testCtx = testCanvas.getContext('2d');
                testCtx.fillStyle = '#e0e0e0';
                testCtx.fillRect(0, 0, testCanvas.width, testCanvas.height);
                
                // 测试渲染
                const testText = "A";
                LCDFont.renderText(testCtx, font_8x8, testText, 10, 10, '#000000', null, 1, 2);
                
                // 获取像素数据并检查
                const imgData = testCtx.getImageData(0, 0, testCanvas.width, testCanvas.height);
                const pixels = imgData.data;
                
                // 添加一个用于显示调试信息的div
                const debugDiv = document.createElement('div');
                debugDiv.style.fontFamily = 'monospace';
                debugDiv.style.fontSize = '12px';
                debugDiv.style.whiteSpace = 'pre';
                debugDiv.style.margin = '10px';
                debugDiv.style.padding = '10px';
                debugDiv.style.border = '1px solid #ccc';
                debugDiv.style.backgroundColor = '#f0f0f0';
                document.body.appendChild(debugDiv);
                
                debugDiv.textContent = "字符 'A' 像素检查 (8x8像素区域):\n";
                
                // 创建ASCII图示,显示字符的每个像素
                let asciiMap = "";
                let blackCount = 0;
                
                for (let y = 10; y < 18; y++) {
                    for (let x = 10; x < 18; x++) {
                        const idx = (y * testCanvas.width + x) * 4;
                        const r = pixels[idx];
                        const g = pixels[idx+1];
                        const b = pixels[idx+2];
                        const a = pixels[idx+3];
                        
                        // 判断是否为黑色像素
                        const isBlack = a > 0 && (r < 100 && g < 100 && b < 100);
                        
                        if (isBlack) {
                            asciiMap += "█";
                            blackCount++;
                        } else {
                            asciiMap += "·";
                        }
                    }
                    asciiMap += "\n";
                }
                
                debugDiv.textContent += asciiMap;
                debugDiv.textContent += `\n检测到 ${blackCount} 个黑色像素`;
                
                console.log("LCDFont测试完成");
            } catch (error) {
                console.error("LCDFont测试失败:", error);
            }
        }
        
        // 切换标签页
        function switchTab(tabName) {
            // 移除所有标签页和按钮的active类
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // 激活选中的标签页和按钮
            document.getElementById(`${tabName}-tab`).classList.add('active');
            document.querySelector(`.tab-button[onclick="switchTab('${tabName}')"]`).classList.add('active');
        }

        // 页面加载完成后执行测试
        // window.addEventListener('load', testLCDFont);  // 注释掉防止调试信息影响界面

        // 在页面加载完成后初始化
        window.addEventListener('load', function() {
            // 检查二维码库是否加载成功
            checkQRCodeLibrary();
            
            // 初始化图片处理事件监听器
            setupImageProcessingEventListeners();
            

            
            // 添加二维码功能的事件监听器
            setupQRCodeEventListeners();
        });

        // 设置二维码相关的事件监听器
        function setupQRCodeEventListeners() {
            // 实时验证二维码内容
            const qrTextArea = document.getElementById('qrText');
            qrTextArea.addEventListener('input', function() {
                const validation = validateQRContent(this.value);
                if (!validation.valid && this.value.trim().length > 0) {
                    this.style.borderColor = '#ff0000';
                    this.title = validation.message;
                } else {
                    this.style.borderColor = '';
                    this.title = '';
                }
            });

            // 纠错级别变化时更新容量提示
            const errorLevelSelect = document.getElementById('qrErrorLevel');
            errorLevelSelect.addEventListener('change', function() {
                updateCapacityHint();
            });

            // 版本选择变化时更新预期尺寸
            const versionSelect = document.getElementById('qrVersion');
            versionSelect.addEventListener('change', function() {
                updateSizeHint();
            });

            // 添加快捷键支持
            qrTextArea.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    generateQRCode();
                }
            });
            
            // 快速输入框支持回车键生成（如果元素存在）
            const quickQrText = document.getElementById('quickQrText');
            if (quickQrText) {
                quickQrText.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        quickGenerateQR();
                    }
                });
            }
        }

        // 更新容量提示
        function updateCapacityHint() {
            const capacity = getQRCapacityInfo();
            const errorLevel = document.getElementById('qrErrorLevel').value;
            
            // 可以在界面上显示容量提示
            console.log(`当前纠错级别 ${errorLevel} 的容量范围: ${capacity.version1} - ${capacity.version10} 个数字字符`);
        }

        // 更新尺寸提示
        function updateSizeHint() {
            const version = document.getElementById('qrVersion').value;
            if (version !== 'auto') {
                const size = 17 + 4 * parseInt(version); // QR码尺寸计算公式
                console.log(`版本 ${version} 的二维码尺寸: ${size}x${size} 像素`);
            }
        }

        // 二维码生成功能
        async function generateQRCode() {
            if (typeof QRCode === 'undefined') {
                alert('二维码库未加载，请刷新页面重试');
                return;
            }

            const text = document.getElementById('qrText').value.trim();
            if (!text) {
                alert('请输入要生成二维码的内容');
                return;
            }

            const errorLevel = document.getElementById('qrErrorLevel').value;
            const version = document.getElementById('qrVersion').value;
            const x = parseInt(document.getElementById('qrX').value) || 0;
            const y = parseInt(document.getElementById('qrY').value) || 0;
            const invert = document.getElementById('qrInvert').checked;

            try {
                // 配置二维码选项
                const options = {
                    errorCorrectionLevel: errorLevel,
                    margin: 1,
                    scale: 1,
                    width: undefined // 让库自动计算合适的尺寸
                };

                // 如果不是自动选择版本，则指定版本
                if (version !== 'auto') {
                    options.version = parseInt(version);
                }

                // 创建临时canvas
                const qrCanvas = document.createElement('canvas');
                
                // 尝试使用toCanvas方法
                try {
                    await QRCode.toCanvas(qrCanvas, text, options);
                } catch (e) {
                    console.error('toCanvas方法失败，尝试其他方法:', e);
                    
                    // 如果toCanvas失败，尝试使用QRCode构造函数
                    const qr = new QRCode(qrCanvas, {
                        text: text,
                        width: 128,
                        height: 128,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel[errorLevel]
                    });
                }

                // 更新预览
                updateQRPreview(qrCanvas);

                // 将二维码绘制到主画布
                drawQRCodeToMainCanvas(qrCanvas, x, y, invert);

            } catch (error) {
                console.error('二维码生成失败:', error);
                alert('二维码生成失败，请检查输入内容和参数设置。\n错误信息: ' + error.message);
            }
        }

        // 快速生成二维码功能
        async function quickGenerateQR() {
            if (typeof QRCode === 'undefined') {
                alert('二维码库未加载，请刷新页面重试');
                return;
            }

            const text = document.getElementById('quickQrText').value.trim();
            if (!text) {
                alert('请输入要生成二维码的内容');
                return;
            }

            try {
                // 使用默认设置快速生成
                const options = {
                    errorCorrectionLevel: 'M',
                    margin: 1,
                    scale: 1,
                    width: undefined
                };

                const qrCanvas = document.createElement('canvas');
                
                try {
                    await QRCode.toCanvas(qrCanvas, text, options);
                } catch (e) {
                    console.error('toCanvas方法失败，尝试其他方法:', e);
                    
                    const qr = new QRCode(qrCanvas, {
                        text: text,
                        width: 128,
                        height: 128,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel.M
                    });
                }

                // 获取当前像素模式
                const pixelMode = parseInt(document.getElementById('qrPixelMode').value);
                
                // 智能定位：找一个合适的位置放置二维码
                const canvasWidth = parseInt(document.getElementById('width').value);
                const canvasHeight = parseInt(document.getElementById('height').value);
                
                let x = 0, y = 0;
                
                // 考虑像素模式计算实际尺寸
                const actualWidth = qrCanvas.width * pixelMode;
                const actualHeight = qrCanvas.height * pixelMode;
                
                // 如果屏幕足够大，尝试放在右上角
                if (canvasWidth >= actualWidth + 10 && canvasHeight >= actualHeight + 10) {
                    x = Math.max(0, canvasWidth - actualWidth - 5);
                    y = 5;
                }

                // 自动更新左侧面板的参数
                document.getElementById('qrText').value = text;
                document.getElementById('qrX').value = x;
                document.getElementById('qrY').value = y;

                // 更新预览
                updateQRPreview(qrCanvas);

                // 绘制到主画布
                drawQRCodeToMainCanvas(qrCanvas, x, y, false);

                // 清空快速输入框
                document.getElementById('quickQrText').value = '';

                console.log(`快速生成二维码成功: "${text}" at (${x}, ${y}), 像素模式: ${pixelMode}x${pixelMode}`);

            } catch (error) {
                console.error('快速生成二维码失败:', error);
                alert('二维码生成失败，请检查输入内容。\n错误信息: ' + error.message);
            }
        }

        // 检查二维码库是否加载成功
        function checkQRCodeLibrary() {
            if (typeof QRCode === 'undefined') {
                console.error('QRCode库未加载');
                // 尝试重新加载
                loadBackupQRCode();
                return false;
            }
            return true;
        }

        // 验证二维码内容的合法性
        function validateQRContent(text) {
            if (!text || text.trim().length === 0) {
                return { valid: false, message: '内容不能为空' };
            }

            // 检查内容长度（不同纠错级别和版本有不同的容量限制）
            const errorLevel = document.getElementById('qrErrorLevel').value;
            const version = document.getElementById('qrVersion').value;

            // 简单的长度检查（具体限制取决于内容类型和纠错级别）
            if (text.length > 2000) {
                return { valid: false, message: '内容过长，请减少字符数量' };
            }

            return { valid: true, message: '' };
        }

        // 获取二维码容量信息
        function getQRCapacityInfo() {
            const errorLevel = document.getElementById('qrErrorLevel').value;
            
            // 返回不同纠错级别下的大致容量（数字字符）
            const capacities = {
                'L': { version1: 41, version10: 331 },
                'M': { version1: 34, version10: 271 },
                'Q': { version1: 27, version10: 213 },
                'H': { version1: 17, version10: 131 }
            };

            return capacities[errorLevel] || capacities['M'];
        }

        // 添加一些常用的二维码模板
        function insertQRTemplate(template) {
            const qrTextArea = document.getElementById('qrText');
            switch (template) {
                case 'url':
                    qrTextArea.value = 'https://';
                    break;
                case 'wifi':
                    qrTextArea.value = 'WIFI:T:WPA;S:WiFi名称;P:密码;;';
                    break;
                case 'email':
                    qrTextArea.value = 'mailto:example@email.com?subject=主题&body=内容';
                    break;
                case 'phone':
                    qrTextArea.value = 'tel:+86';
                    break;
                case 'sms':
                    qrTextArea.value = 'sms:+86:消息内容';
                    break;
                case 'vcard':
                    qrTextArea.value = 'BEGIN:VCARD\nVERSION:3.0\nFN:姓名\nORG:公司\nTEL:电话\nEMAIL:邮箱\nEND:VCARD';
                    break;
                default:
                    qrTextArea.value = '示例文本';
            }
            qrTextArea.focus();
        }



        // 更新二维码预览
        function updateQRPreview(qrCanvas) {
            const previewDiv = document.getElementById('qrPreview');
            previewDiv.innerHTML = '';
            
            // 创建缩小版的预览图
            const previewCanvas = document.createElement('canvas');
            const previewCtx = previewCanvas.getContext('2d');
            const maxSize = 150; // 预览最大尺寸
            
            const scale = Math.min(maxSize / qrCanvas.width, maxSize / qrCanvas.height);
            previewCanvas.width = qrCanvas.width * scale;
            previewCanvas.height = qrCanvas.height * scale;
            
            previewCtx.imageSmoothingEnabled = false; // 保持像素清晰
            previewCtx.drawImage(qrCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
            
            previewCanvas.style.border = '1px solid #ccc';
            previewDiv.appendChild(previewCanvas);
            
            // 添加尺寸信息
            const sizeInfo = document.createElement('div');
            sizeInfo.style.fontSize = '10px';
            sizeInfo.style.color = '#666';
            sizeInfo.style.marginTop = '5px';
            sizeInfo.textContent = `${qrCanvas.width}x${qrCanvas.height} 像素`;
            previewDiv.appendChild(sizeInfo);
        }

        // 将二维码绘制到主画布
        function drawQRCodeToMainCanvas(qrCanvas, startX, startY, invert) {
            // 保存当前状态用于撤销
            saveState();

            const qrCtx = qrCanvas.getContext('2d');
            const qrImageData = qrCtx.getImageData(0, 0, qrCanvas.width, qrCanvas.height);
            const qrPixels = qrImageData.data;

            const canvasWidth = parseInt(document.getElementById('width').value);
            const canvasHeight = parseInt(document.getElementById('height').value);
            
            // 获取像素模式
            const pixelMode = parseInt(document.getElementById('qrPixelMode').value);
            
            // 遍历二维码的每个像素
            for (let qrY = 0; qrY < qrCanvas.height; qrY++) {
                for (let qrX = 0; qrX < qrCanvas.width; qrX++) {
                    const pixelIndex = (qrY * qrCanvas.width + qrX) * 4;
                    const r = qrPixels[pixelIndex];
                    const g = qrPixels[pixelIndex + 1];
                    const b = qrPixels[pixelIndex + 2];
                    const a = qrPixels[pixelIndex + 3];

                    // 判断是否为黑色像素 (考虑透明度)
                    const isBlack = a > 128 && (r + g + b) / 3 < 128;
                    
                    // 计算在主画布上的基础位置
                    const baseX = startX + qrX * pixelMode;
                    const baseY = startY + qrY * pixelMode;

                    // 根据像素模式绘制对应大小的方块
                    for (let py = 0; py < pixelMode; py++) {
                        for (let px = 0; px < pixelMode; px++) {
                            const mainX = baseX + px;
                            const mainY = baseY + py;

                            // 检查边界
                            if (mainX >= 0 && mainX < canvasWidth && mainY >= 0 && mainY < canvasHeight) {
                                // 根据invert设置来决定像素值
                                if (invert) {
                                    bitmap[mainY][mainX] = isBlack ? 0 : 1; // 反转：黑变白，白变黑
                                } else {
                                    bitmap[mainY][mainX] = isBlack ? 1 : 0; // 正常：黑为1，白为0
                                }
                            }
                        }
                    }
                }
            }

            // 重新绘制画布
            drawBitmap();

            console.log(`二维码已绘制到位置 (${startX}, ${startY})，尺寸: ${qrCanvas.width * pixelMode}x${qrCanvas.height * pixelMode}，像素模式: ${pixelMode}x${pixelMode}`);
        }

        // 图片处理相关变量和函数
        let currentImageData = null;
        let originalImage = null;

        // 更新阈值显示值
        function updateThresholdValue(value) {
            document.getElementById('thresholdValue').textContent = value;
        }

        // 设置图片处理相关的事件监听器
        function setupImageProcessingEventListeners() {
            // 文件选择事件
            const imageUpload = document.getElementById('imageUpload');
            imageUpload.addEventListener('change', handleImageUpload);

            // 缩放模式变化事件
            const scaleMode = document.getElementById('scaleMode');
            scaleMode.addEventListener('change', function() {
                const customScaleGroup = document.getElementById('customScaleGroup');
                if (this.value === 'custom') {
                    customScaleGroup.style.display = 'block';
                } else {
                    customScaleGroup.style.display = 'none';
                }
                
                // 如果已有图片，重新生成预览
                if (originalImage) {
                    generateImagePreview();
                }
            });

            // 自定义缩放比例变化事件
            const customScale = document.getElementById('customScale');
            customScale.addEventListener('input', function() {
                if (originalImage && document.getElementById('scaleMode').value === 'custom') {
                    generateImagePreview();
                }
            });

            // 阈值变化时重新生成预览
            const colorThreshold = document.getElementById('colorThreshold');
            colorThreshold.addEventListener('input', function() {
                if (originalImage) {
                    generateImagePreview();
                }
            });

            // 反转颜色变化时重新生成预览
            const imageInvert = document.getElementById('imageInvert');
            imageInvert.addEventListener('change', function() {
                if (originalImage) {
                    generateImagePreview();
                }
            });
        }

        // 处理图片上传
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                resetImageProcessing();
                return;
            }

            // 检查文件类型
            const allowedTypes = ['image/png', 'image/bmp'];
            if (!allowedTypes.includes(file.type)) {
                alert('只支持PNG和BMP格式的图片！');
                event.target.value = '';
                resetImageProcessing();
                return;
            }

            // 检查文件大小（限制在10MB以内）
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxSize) {
                alert('图片文件过大，请选择小于10MB的图片！');
                event.target.value = '';
                resetImageProcessing();
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    updateImageInfo(img, file);
                    generateImagePreview();
                };
                img.onerror = function() {
                    alert('图片加载失败，请检查文件格式！');
                    resetImageProcessing();
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                alert('文件读取失败！');
                resetImageProcessing();
            };
            reader.readAsDataURL(file);
        }

        // 重置图片处理
        function resetImageProcessing() {
            originalImage = null;
            currentImageData = null;
            document.getElementById('imagePreview').innerHTML = '<div style="font-size: 12px; color: #666;">图片预览</div>';
            document.getElementById('imageInfo').textContent = '尚未选择图片';
        }

        // 更新图片信息显示
        function updateImageInfo(img, file) {
            const sizeKB = Math.round(file.size / 1024);
            const infoText = `${img.width}×${img.height} 像素, ${sizeKB}KB`;
            document.getElementById('imageInfo').textContent = infoText;
        }

        // 生成图片预览
        function generateImagePreview() {
            if (!originalImage) return;

            const canvasWidth = parseInt(document.getElementById('width').value);
            const canvasHeight = parseInt(document.getElementById('height').value);
            const scaleMode = document.getElementById('scaleMode').value;
            const customScaleValue = parseFloat(document.getElementById('customScale').value);
            const threshold = parseInt(document.getElementById('colorThreshold').value);
            const invert = document.getElementById('imageInvert').checked;

            // 计算目标尺寸
            const targetSize = calculateTargetSize(originalImage.width, originalImage.height, canvasWidth, canvasHeight, scaleMode, customScaleValue);

            // 创建临时canvas进行处理
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = targetSize.width;
            tempCanvas.height = targetSize.height;

            // 绘制缩放后的图片
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.drawImage(originalImage, 0, 0, targetSize.width, targetSize.height);

            // 获取像素数据
            const imageData = tempCtx.getImageData(0, 0, targetSize.width, targetSize.height);
            const processedData = processImageData(imageData, threshold, invert);

            // 保存处理后的数据
            currentImageData = {
                width: targetSize.width,
                height: targetSize.height,
                data: processedData
            };

            // 生成预览
            updateImagePreview(targetSize.width, targetSize.height, processedData);
        }

        // 计算目标尺寸
        function calculateTargetSize(imgWidth, imgHeight, canvasWidth, canvasHeight, scaleMode, customScale) {
            let targetWidth, targetHeight;

            switch (scaleMode) {
                case 'fit':
                    // 适应屏幕（保持比例）
                    const fitScale = Math.min(canvasWidth / imgWidth, canvasHeight / imgHeight);
                    targetWidth = Math.round(imgWidth * fitScale);
                    targetHeight = Math.round(imgHeight * fitScale);
                    break;

                case 'fill':
                    // 填充屏幕（可能裁剪）
                    const fillScale = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);
                    targetWidth = Math.min(Math.round(imgWidth * fillScale), canvasWidth);
                    targetHeight = Math.min(Math.round(imgHeight * fillScale), canvasHeight);
                    break;

                case 'original':
                    // 原始尺寸
                    targetWidth = Math.min(imgWidth, canvasWidth);
                    targetHeight = Math.min(imgHeight, canvasHeight);
                    break;

                case 'custom':
                    // 自定义比例
                    targetWidth = Math.min(Math.round(imgWidth * customScale), canvasWidth);
                    targetHeight = Math.min(Math.round(imgHeight * customScale), canvasHeight);
                    break;

                default:
                    targetWidth = imgWidth;
                    targetHeight = imgHeight;
            }

            return { width: targetWidth, height: targetHeight };
        }

        // 处理图片数据（转换为单色）
        function processImageData(imageData, threshold, invert) {
            const pixels = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const result = [];

            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    const r = pixels[index];
                    const g = pixels[index + 1];
                    const b = pixels[index + 2];
                    const alpha = pixels[index + 3];

                    // 计算灰度值（加权平均）
                    const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                    
                    // 考虑透明度
                    const effectiveGray = alpha < 128 ? 255 : gray; // 透明像素视为白色
                    
                    // 根据阈值判断是否为黑色像素
                    let isBlack = effectiveGray < threshold;
                    
                    // 如果反转，则翻转结果
                    if (invert) {
                        isBlack = !isBlack;
                    }
                    
                    row.push(isBlack ? 1 : 0);
                }
                result.push(row);
            }

            return result;
        }

        // 更新图片预览显示
        function updateImagePreview(width, height, data) {
            const previewDiv = document.getElementById('imagePreview');
            previewDiv.innerHTML = '';

            // 创建预览canvas
            const previewCanvas = document.createElement('canvas');
            const previewCtx = previewCanvas.getContext('2d');
            
            // 设置预览大小（最大150px）
            const maxPreviewSize = 150;
            const previewScale = Math.min(maxPreviewSize / width, maxPreviewSize / height);
            previewCanvas.width = width * previewScale;
            previewCanvas.height = height * previewScale;

            // 绘制预览
            previewCtx.fillStyle = LCD_BACKGROUND;
            previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            previewCtx.fillStyle = 'black';
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (data[y][x]) {
                        previewCtx.fillRect(
                            x * previewScale, 
                            y * previewScale, 
                            previewScale, 
                            previewScale
                        );
                    }
                }
            }

            previewCanvas.style.border = '1px solid #ccc';
            previewDiv.appendChild(previewCanvas);

            // 添加尺寸信息
            const sizeInfo = document.createElement('div');
            sizeInfo.style.fontSize = '10px';
            sizeInfo.style.color = '#666';
            sizeInfo.style.marginTop = '5px';
            sizeInfo.textContent = `处理后: ${width}×${height} 像素`;
            previewDiv.appendChild(sizeInfo);
        }

        // 处理并绘制图片到主画布
        function processAndDrawImage() {
            if (!currentImageData) {
                alert('请先选择并预览图片！');
                return;
            }

            // 保存当前状态用于撤销
            saveState();

            const x = parseInt(document.getElementById('imageX').value) || 0;
            const y = parseInt(document.getElementById('imageY').value) || 0;
            const canvasWidth = parseInt(document.getElementById('width').value);
            const canvasHeight = parseInt(document.getElementById('height').value);

            const imgWidth = currentImageData.width;
            const imgHeight = currentImageData.height;
            const imgData = currentImageData.data;

            // 将图片数据绘制到主画布
            for (let imgY = 0; imgY < imgHeight; imgY++) {
                for (let imgX = 0; imgX < imgWidth; imgX++) {
                    const targetX = x + imgX;
                    const targetY = y + imgY;

                    // 检查边界
                    if (targetX >= 0 && targetX < canvasWidth && targetY >= 0 && targetY < canvasHeight) {
                        bitmap[targetY][targetX] = imgData[imgY][imgX];
                    }
                }
            }

            // 重新绘制画布
            drawBitmap();

            console.log(`图片已绘制到位置 (${x}, ${y})，尺寸: ${imgWidth}×${imgHeight}`);
            alert(`图片处理完成！已绘制到位置 (${x}, ${y})`);
        }

        // 快速处理图片功能
        function quickProcessImage() {
            const quickUpload = document.getElementById('quickImageUpload');
            const file = quickUpload.files[0];
            
            if (!file) {
                alert('请先选择一个图片文件！');
                return;
            }

            // 检查文件类型
            const allowedTypes = ['image/png', 'image/bmp'];
            if (!allowedTypes.includes(file.type)) {
                alert('只支持PNG和BMP格式的图片！');
                quickUpload.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // 使用默认设置快速处理
                    const canvasWidth = parseInt(document.getElementById('width').value);
                    const canvasHeight = parseInt(document.getElementById('height').value);
                    
                    // 智能缩放：适应屏幕
                    const fitScale = Math.min(canvasWidth / img.width, canvasHeight / img.height);
                    const targetWidth = Math.round(img.width * fitScale);
                    const targetHeight = Math.round(img.height * fitScale);
                    
                    // 创建临时canvas处理
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = targetWidth;
                    tempCanvas.height = targetHeight;
                    
                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.drawImage(img, 0, 0, targetWidth, targetHeight);
                    
                    // 获取像素数据并处理（使用默认阈值128）
                    const imageData = tempCtx.getImageData(0, 0, targetWidth, targetHeight);
                    const processedData = processImageData(imageData, 128, false);
                    
                    // 保存当前状态用于撤销
                    saveState();
                    
                    // 智能定位：尝试放在画布中央
                    const x = Math.max(0, Math.floor((canvasWidth - targetWidth) / 2));
                    const y = Math.max(0, Math.floor((canvasHeight - targetHeight) / 2));
                    
                    // 将图片数据绘制到主画布
                    for (let imgY = 0; imgY < targetHeight; imgY++) {
                        for (let imgX = 0; imgX < targetWidth; imgX++) {
                            const targetX = x + imgX;
                            const targetY = y + imgY;
                            
                            if (targetX >= 0 && targetX < canvasWidth && targetY >= 0 && targetY < canvasHeight) {
                                bitmap[targetY][targetX] = processedData[imgY][imgX];
                            }
                        }
                    }
                    
                    // 重新绘制画布
                    drawBitmap();
                    
                    // 同步更新左侧面板的参数
                    document.getElementById('imageUpload').value = '';
                    document.getElementById('scaleMode').value = 'fit';
                    document.getElementById('colorThreshold').value = 128;
                    document.getElementById('thresholdValue').textContent = '128';
                    document.getElementById('imageX').value = x;
                    document.getElementById('imageY').value = y;
                    document.getElementById('imageInvert').checked = false;
                    
                    // 清空快速上传
                    quickUpload.value = '';
                    
                    console.log(`快速处理图片成功: ${targetWidth}×${targetHeight} at (${x}, ${y})`);
                    alert(`图片快速处理完成！已放置在位置 (${x}, ${y})`);
                };
                img.onerror = function() {
                    alert('图片加载失败，请检查文件格式！');
                    quickUpload.value = '';
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                alert('文件读取失败！');
                quickUpload.value = '';
            };
            reader.readAsDataURL(file);
        }

        // 设置快速图片上传的事件监听器
        function setupQuickImageEventListeners() {
            const quickImageUpload = document.getElementById('quickImageUpload');
            
            // 支持拖拽文件
            quickImageUpload.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.style.backgroundColor = '#e3f2fd';
            });
            
            quickImageUpload.addEventListener('dragleave', function(e) {
                e.preventDefault();
                this.style.backgroundColor = '';
            });
            
            quickImageUpload.addEventListener('drop', function(e) {
                e.preventDefault();
                this.style.backgroundColor = '';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.files = files;
                    // 自动触发快速处理
                    setTimeout(quickProcessImage, 100);
                }
            });
        }

    </script>
</body>
</html> 